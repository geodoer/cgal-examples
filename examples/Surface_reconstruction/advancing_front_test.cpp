#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Point_set_3.h>
#include <CGAL/Point_set_3/IO.h>
#include <CGAL/remove_outliers.h>
#include <CGAL/grid_simplify_point_set.h>
#include <CGAL/jet_smooth_point_set.h>
#include <CGAL/jet_estimate_normals.h>
#include <CGAL/mst_orient_normals.h>
#include <CGAL/poisson_surface_reconstruction.h>
#include <CGAL/Advancing_front_surface_reconstruction.h>
#include <CGAL/Scale_space_surface_reconstruction_3.h>
#include <CGAL/Scale_space_reconstruction_3/Jet_smoother.h>
#include <CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h>
#include <CGAL/Surface_mesh.h>
#include <CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h>

#include <cstdlib>
#include <vector>
#include <fstream>
// types
typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::FT FT;
typedef Kernel::Point_3 Point_3;
typedef Kernel::Vector_3 Vector_3;
typedef Kernel::Sphere_3 Sphere_3;
typedef CGAL::Point_set_3<Point_3, Vector_3> Point_set;

typedef std::array<std::size_t, 3> Facet; // Triple of indices 三角形（索引形式）
std::vector<Facet> facets;
namespace std {
	std::ostream&
		operator<<(std::ostream& os, const Facet& f)
	{
		os << "3 " << f[0] << " " << f[1] << " " << f[2];
		return os;
	}
}

int main(int argc, char* argv[])
{
	std::string fname = R"(C:\Users\geodoer\Desktop\mesh_rec_test\TopReconstruction\mesh_to_points.ply)";
	std::string out_name = fname + ".advancing_front.off";

	Point_set points;

	//# 读取输入文件
	std::ifstream stream(fname, std::ios_base::binary);
	if (!stream)
	{
		std::cerr << "Error: cannot read file " << fname << std::endl;
		return EXIT_FAILURE;
	}
	stream >> points;
	std::cout << "Read " << points.size() << " point(s)" << std::endl;
	if (points.empty())
	{
		return EXIT_FAILURE;
	}

	//# 去除离群点
	if (true)
	{
		typename Point_set::iterator rout_it = CGAL::remove_outliers<CGAL::Sequential_tag>(points,
			10, // Number of neighbors considered for evaluation	邻居数
			points.parameters().threshold_percent(2.0)	// Percentage of points to remove 移除百分比
		);
		points.remove(rout_it, points.end());
		std::cout << points.number_of_removed_points() << " point(s) are outliers." << std::endl;
		// Applying point set processing algorithm to a CGAL::Point_set_3
		// object does not erase the points from memory but place them in
		// the garbage of the object: memory can be freeed by the user.
		points.collect_garbage();	//上面的remove方法应该是懒操作。只有调用函数之后，才作用于原始内存中
	}

	////# 做网格简化
	if (false)
	{
		// Compute average spacing using neighborhood of 6 points
		//用6个点的邻域计算平均间距
		double spacing = CGAL::compute_average_spacing<CGAL::Sequential_tag>(points, 6);
		// Simplify using a grid of size 2 * average spacing
		//做网格简化，网格大小=2*平均间距
		typename Point_set::iterator gsim_it = CGAL::grid_simplify_point_set(points, 2. * spacing);
		points.remove(gsim_it, points.end());
		std::cout << points.number_of_removed_points()
			<< " point(s) removed after simplification." << std::endl;
		points.collect_garbage();
	}

	////# 平滑点云
	if (false)
	{
		CGAL::jet_smooth_point_set<CGAL::Sequential_tag>(points, 24);
	}

	//前沿推进法返回的是 索引式的三角形（PolygonSoup）
	// The function is called using directly the points raw iterators
	CGAL::advancing_front_surface_reconstruction(points.points().begin(), points.points().end(),
		std::back_inserter(facets)
	);
	std::cout << facets.size() << " facet(s) generated by reconstruction." << std::endl;

	//直接保存PolygonSoup
	if(true) 
	{
		std::ofstream f(out_name);
		f << "OFF\n" << points.points().size() << " " << facets.size() << " 0\n"; // Header

		for (auto it = points.begin(), end = points.end();
			it != end;
			++it)
		{
			auto p = points.point(*it);
			f << p << std::endl;
		}

		for (std::size_t i = 0, size = facets.size(); i < size; ++i)
		{
			f << "3 "
				<< facets[i][0] << " "
				<< facets[i][1] << " "
				<< facets[i][2] << std::endl;
		}

		f.close();
	}
	else
	{
		//将PolygonSoup转成PolygonMesh，并输出
		// copy points for random access
		std::vector<Point_3> vertices;
		vertices.reserve(points.size());
		std::copy(points.points().begin(), points.points().end(), std::back_inserter(vertices));
		CGAL::Surface_mesh<Point_3> output_mesh;
		CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(vertices, facets, output_mesh);
		std::ofstream f(out_name);
		f << output_mesh;
		f.close();
	}

	return 0;
}